define flags
    # call the auxiliary functions based on target cpu
    if $ARM == 1
        flagsarm
    else
        flagsx86
    end
end
document flags
Syntax: flags
| Print flags register.
end

define eflags
    if $ARM == 1
        # http://www.heyrick.co.uk/armwiki/The_Status_register
        printf "     N <%d>  Z <%d>  C <%d>  V <%d>",\
               (($cpsr >> 0x1f) & 1), (($cpsr >> 0x1e) & 1), \
               (($cpsr >> 0x1d) & 1), (($cpsr >> 0x1c) & 1)
        printf "  Q <%d>  J <%d>  GE <%d>  E <%d>  A <%d>",\
               (($cpsr >> 0x1b) & 1), (($cpsr >> 0x18) & 1),\
               (($cpsr >> 0x10) & 7), (($cpsr >> 9) & 1), (($cpsr >> 8) & 1)
        printf "  I <%d>  F <%d>  T <%d> \n",\
               (($cpsr >> 7) & 1), (($cpsr >> 6) & 1), \
               (($cpsr >> 5) & 1)
     else
        printf "     OF <%d>  DF <%d>  IF <%d>  TF <%d>",\
               (((unsigned int)$eflags >> 0xB) & 1), (((unsigned int)$eflags >> 0xA) & 1), \
               (((unsigned int)$eflags >> 9) & 1), (((unsigned int)$eflags >> 8) & 1)
        printf "  SF <%d>  ZF <%d>  AF <%d>  PF <%d>  CF <%d>\n",\
               (((unsigned int)$eflags >> 7) & 1), (((unsigned int)$eflags >> 6) & 1),\
               (((unsigned int)$eflags >> 4) & 1), (((unsigned int)$eflags >> 2) & 1), ((unsigned int)$eflags & 1)
        printf "     ID <%d>  VIP <%d> VIF <%d> AC <%d>",\
               (((unsigned int)$eflags >> 0x15) & 1), (((unsigned int)$eflags >> 0x14) & 1), \
               (((unsigned int)$eflags >> 0x13) & 1), (((unsigned int)$eflags >> 0x12) & 1)
        printf "  VM <%d>  RF <%d>  NT <%d>  IOPL <%d>\n",\
               (((unsigned int)$eflags >> 0x11) & 1), (((unsigned int)$eflags >> 0x10) & 1),\
               (((unsigned int)$eflags >> 0xE) & 1), (((unsigned int)$eflags >> 0xC) & 3)
     end
end
document eflags
Syntax: eflags
| Print eflags register.
end

# Initialize these variables else comparisons will fail for coloring
# we must initialize all of them at once, 32 and 64 bits, and ARM.
set $oldrax = 0
set $oldrbx = 0
set $oldrcx = 0
set $oldrdx = 0
set $oldrsi = 0
set $oldrdi = 0
set $oldrbp = 0
set $oldrsp = 0
set $oldr8  = 0
set $oldr9  = 0
set $oldr10 = 0
set $oldr11 = 0
set $oldr12 = 0
set $oldr13 = 0
set $oldr14 = 0
set $oldr15 = 0
set $oldeax = 0
set $oldebx = 0
set $oldecx = 0
set $oldedx = 0
set $oldesi = 0
set $oldedi = 0
set $oldebp = 0
set $oldesp = 0
set $oldr0  = 0
set $oldr1  = 0
set $oldr2  = 0
set $oldr3  = 0
set $oldr4  = 0
set $oldr5  = 0
set $oldr6  = 0
set $oldr7  = 0
set $oldsp  = 0
set $oldlr  = 0



define reg
    if $ARM == 1
        regarm
	    if ($SHOWREGCHANGES == 1)
	        set $oldr0  = $r0
	        set $oldr1  = $r1
	        set $oldr2  = $r2
	        set $oldr3  = $r3
	        set $oldr4  = $r4
	        set $oldr5  = $r5
	        set $oldr6  = $r6
	        set $oldr7  = $r7
	        set $oldr8  = $r8
    		set $oldr9  = $r9
	    	set $oldr10 = $r10
		    set $oldr11 = $r11
			set $oldr12 = $r12
			set $oldsp  = $sp
			set $oldlr  = $lr
	    end
    else
        if ($64BITS == 1)
            regx64
        else
            regx86
        end
        # call smallregisters
	    smallregisters
        # display conditional jump routine
	    if ($64BITS == 1)
    	    printf "\t\t\t\t"
    	end
        dumpjump
        printf "\n"
        if ($SHOWREGCHANGES == 1)
    	    if ($64BITS == 1)
	        	set $oldrax = $rax
			    set $oldrbx = $rbx
    			set $oldrcx = $rcx
	    		set $oldrdx = $rdx
		    	set $oldrsi = $rsi
    			set $oldrdi = $rdi
	    		set $oldrbp = $rbp
		    	set $oldrsp = $rsp
			    set $oldr8  = $r8
    			set $oldr9  = $r9
	    		set $oldr10 = $r10
		    	set $oldr11 = $r11
			    set $oldr12 = $r12
    			set $oldr13 = $r13
	    		set $oldr14 = $r14
		    	set $oldr15 = $r15
    		else
	        	set $oldeax = $eax
		    	set $oldebx = $ebx
			    set $oldecx = $ecx
    			set $oldedx = $edx
	    		set $oldesi = $esi
		    	set $oldedi = $edi
			    set $oldebp = $ebp
			    set $oldesp = $esp
    		end
	    end
    end
end
document reg
Syntax: reg
| Print CPU registers.
end


define smallregisters
    if ($64BITS == 1)
    #64bits stuff
	    # from rax
    	set $eax = $rax & 0xffffffff
    	set $ax  = $rax & 0xffff
    	set $al  = $ax & 0xff
    	set $ah  = $ax >> 8
    	# from rbx
    	set $ebx = $rbx & 0xffffffff
    	set $bx  = $rbx & 0xffff
    	set $bl  = $bx & 0xff
    	set $bh  = $bx >> 8
	    # from rcx
    	set $ecx = $rcx & 0xffffffff
    	set $cx  = $rcx & 0xffff
    	set $cl  = $cx & 0xff
	    set $ch  = $cx >> 8
    	# from rdx
    	set $edx = $rdx & 0xffffffff
    	set $dx  = $rdx & 0xffff
    	set $dl  = $dx & 0xff
    	set $dh  = $dx >> 8
	    # from rsi
    	set $esi = $rsi & 0xffffffff
    	set $si  = $rsi & 0xffff
    	# from rdi
    	set $edi = $rdi & 0xffffffff
    	set $di  = $rdi & 0xffff
    #32 bits stuff
    else
	    # from eax
    	set $ax = $eax & 0xffff
    	set $al = $ax & 0xff
    	set $ah = $ax >> 8
	    # from ebx
    	set $bx = $ebx & 0xffff
    	set $bl = $bx & 0xff
    	set $bh = $bx >> 8
    	# from ecx
    	set $cx = $ecx & 0xffff
    	set $cl = $cx & 0xff
    	set $ch = $cx >> 8
    	# from edx
    	set $dx = $edx & 0xffff
    	set $dl = $dx & 0xff
	    set $dh = $dx >> 8
    	# from esi
    	set $si = $esi & 0xffff
    	# from edi
	    set $di = $edi & 0xffff
     end
end
document smallregisters
Syntax: smallregisters
| Create the 16 and 8 bit cpu registers (gdb doesn't have them by default).
| And 32bits if we are dealing with 64bits binaries.
end

# _______________process context______________
# initialize variable
set $displayobjectivec = 0

define context
    color $COLOR_SEPARATOR
    if $SHOWCPUREGISTERS == 1
	    printf "----------------------------------------"
	    printf "----------------------------------"
	    if ($64BITS == 1)
	        printf "---------------------------------------------"
	    end
	    color $COLOR_SEPARATOR
	    color_bold
	    printf "[regs]\n"
	    color_reset
	    reg
	    color $CYAN
    end
    if $SHOWSTACK == 1
    	color $COLOR_SEPARATOR
		if $ARM == 1
       printf "[0x%08X]", $sp
		else
        if ($64BITS == 1)
		        printf "[0x%04X:0x%016lX]", $ss, $rsp
        else
            printf "[0x%04X:0x%08X]", $ss, $esp
        end
    end
        color $COLOR_SEPARATOR
		printf "-------------------------"
    	printf "-----------------------------"
	    if ($64BITS == 1)
	        printf "-------------------------------------"
	    end
	    color $COLOR_SEPARATOR
	    color_bold
	    printf "[stack]\n"
    	color_reset
    	set $context_i = $CONTEXTSIZE_STACK
    	while ($context_i > 0)
       	    set $context_t = $sp + 0x10 * ($context_i - 1)
       	    hexdump $context_t
       	    set $context_i--
    	end
    end
    # show the objective C message being passed to msgSend
    if $SHOWOBJECTIVEC == 1
        #FIXME: X64 and ARM
        # What a piece of crap that's going on here :)
        # detect if it's the correct opcode we are searching for
        if $ARM == 0
            set $__byte1 = *(unsigned char *)$pc
    	    set $__byte = *(int *)$pc
        	if ($__byte == 0x4244489)
          		set $objectivec = $eax
      	    	set $displayobjectivec = 1
    	    end

        	if ($__byte == 0x4245489)
         		set $objectivec = $edx
     	    	set $displayobjectivec = 1
    	    end

        	if ($__byte == 0x4244c89)
         		set $objectivec = $ecx
     	    	set $displayobjectivec = 1
        	end
        else
            set $__byte1 = 0
        end
        # and now display it or not (we have no interest in having the info displayed after the call)
        if $__byte1 == 0xE8
            if $displayobjectivec == 1
                color $COLOR_SEPARATOR
                printf "--------------------------------------------------------------------"
                if ($64BITS == 1)
                    printf "---------------------------------------------"
                end
                color $COLOR_SEPARATOR
                color_bold
	    		printf "[ObjectiveC]\n"
	    		color_reset
      	    	color $BLACK
      		    x/s $objectivec
         	end
         	set $displayobjectivec = 0
        end
        if $displayobjectivec == 1
            color $COLOR_SEPARATOR
          	printf "--------------------------------------------------------------------"
          	if ($64BITS == 1)
	            printf "---------------------------------------------"
    	    end
    	    color $COLOR_SEPARATOR
    	    color_bold
		    printf "[ObjectiveC]\n"
		    color_reset
          	color $BLACK
          	x/s $objectivec
        end
    end
    color_reset
# and this is the end of this little crap

    if $SHOWDATAWIN == 1
        datawin
    end

    color $COLOR_SEPARATOR
    printf "--------------------------------------------------------------------------"
    if ($64BITS == 1)
	    printf "---------------------------------------------"
	end
	color $COLOR_SEPARATOR
	color_bold
    printf "[code]\n"
    color_reset
    set $context_i = $CONTEXTSIZE_CODE
    if ($context_i > 0)
        if ($SETCOLOR1STLINE == 1)
	        color $GREEN
            if ($ARM == 1)
                #       | $cpsr.t (Thumb flag)
                x/i (unsigned int)$pc | (($cpsr >> 5) & 1)
            else
    	        x/i $pc
            end
	        color_reset
	    else
            if ($ARM == 1)
                #       | $cpsr.t (Thumb flag)
	              x/i (unsigned int)$pc | (($cpsr >> 5) & 1)
            else
                x/i $pc
            end
	    end
        set $context_i--
    end
    while ($context_i > 0)
        x /i
        set $context_i--
    end
    color $COLOR_SEPARATOR
    printf "--------------------------------------------------------------------------"
    if ($64BITS == 1)
	    printf "---------------------------------------------"
    end
    color_bold
    printf"[call stack]\n"
    color_reset
    bt 5
    color $COLOR_SEPARATOR
    printf "----------------------------------------"
    printf "----------------------------------------"
    if ($64BITS == 1)
        printf "---------------------------------------------\n"
    else
        printf "\n"
    end
    color_reset
end
document context
Syntax: context
| Print context window, i.e. regs, stack, ds:esi and disassemble cs:eip.
end


define context-on
    set $SHOW_CONTEXT = 1
    printf "Displaying of context is now ON\n"
end
document context-on
Syntax: context-on
| Enable display of context on every program break.
end


define context-off
    set $SHOW_CONTEXT = 0
    printf "Displaying of context is now OFF\n"
end
document context-off
Syntax: context-off
| Disable display of context on every program break.
end


# Init parameters
#set output-radix 0x10
#set input-radix 0x10
#set disassembly-flavor intel
