
define context-on
set $SHOW_CONTEXT = 1
end
document context-on
Enable display of context on every program stop
end

define context-off
set $SHOW_CONTEXT = 1
end
document context-on
Disable display of context on every program stop
end

# Calls "context" at every breakpoint.
#define hook-stop
#  context
#end

# ____________________misc____________________
define hook-stop
    if (sizeof(void*) == 8)
        set $64BITS = 1
    else
        set $64BITS = 0
    end

    if ($KDP64BITS != -1)
        if ($KDP64BITS == 0)
            set $64BITS = 0
        else
            set $64BITS = 1
        end
    end

    # Display instructions formats
    if $ARM == 1
        if $ARMOPCODES == 1
            set arm show-opcode-bytes 1
        end
    else
        if $X86FLAVOR == 0
            set disassembly-flavor intel
        else
            set disassembly-flavor att
        end
    end

    # this makes 'context' be called at every BP/step
    if ($SHOW_CONTEXT > 0)
        context
    end
    if ($SHOW_NEST_INSN > 0)
        set $x = $_nest
        while ($x > 0)
            printf "\t"
            set $x = $x - 1
        end
    end
end
document hook-stop
Syntax: hook-stop
| !!! FOR INTERNAL USE ONLY - DO NOT CALL !!!
end

define hook-break
    # Don't forget to run the command in the background
    shell cat /tmp/coloutPipe | colout "(Breakpoint) ([0-9]+) at (0x\S+): file (.+/)([^/]+), line ([0-9]+)." blue,red,cyan,none,white,yellow normal,bold,normal,normal,bold,normal &
  # You should start to consume the pipe before actually redirecting the command output into it.
    logging_on
end
define hookpost-break
    logging_off
end


define hook-run
    shell cat /tmp/coloutPipe | colout "^(Breakpoint) ([0-9]+),*\s+(0x\S+ )*(in )*(\S+) (\(.*\)) at (.*/)?(?:$|(.+?)(?:(\.[^.]*)|)):([0-9]+)" red,red,blue,none,green,cpp,none,white,white,yellow normal,bold,normal,normal,bold,normal,normal,bold,bold,bold | colout "^(Starting program): (.*/)?(?:$|(.+?)(?:(\.[^.]*)|)):([0-9]+)" green,none,white,white,yellow normal,normal,bold,bold,bold | colout "^[0-9]+\s+(.*)$" Cpp  &
    logging_on
end
define hookpost-run
    logging_off
end


define hook-continue
    shell cat /tmp/coloutPipe | colout "^(Program received signal )(.*)(,.*)$" yellow,red,yellow bold | colout "^(Breakpoint) ([0-9]+),*\s+(0x\S+ )*(in )*(\S+) (\(.*\)) at (.*/)?(?:$|(.+?)(?:(\.[^.]*)|)):([0-9]+)" red,red,blue,none,green,cpp,none,white,white,yellow normal,bold,normal,normal,bold,normal,normal,bold,bold,bold | colout "^[0-9]+\s+(.*)$" Cpp &
    logging_on
end
define hookpost-continue
    logging_off
end


# Full syntax highlighting for the `list` command.
define hook-list
    shell cat /tmp/coloutPipe | colout --all --source cpp &
    logging_on
end
# Don't forget the hookpost- or next coloring commands will fail.
define hookpost-list
    logging_off
end


define hook-backtrace
    # match the [path]file[.ext]: (.*/)?(?:$|(.+?)(?:(\.[^.]*)|))
    shell cat /tmp/coloutPipe | colout "^(#)([0-9]+)\s+(0x\S+ )*(in )*(\S+) (\(.*\)) at (.*/)?(?:$|(.+?)(?:(\.[^.]*)|)):([0-9]+)" red,red,blue,none,green,cpp,none,white,white,yellow normal,bold,normal,normal,bold,normal,normal,bold,bold,bold &
    logging_on
end
define hookpost-backtrace
    logging_off
end


define info hook-breakpoints
    shell cat /tmp/coloutPipe | colout "^([0-9]+)" red bold | colout "\sy\s" green | colout "\sn\s" red | colout "breakpoint" green normal | colout "watchpoint" orange normal | colout "\s0x\S+\s" blue normal | colout "(.*/)?(?:$|(.+?)(?:(\.[^.]*)|)):([0-9]+)$" none,white,white,yellow normal,bold &
    logging_on
end
define info hookpost-breakpoints
    logging_off
end


define info hook-line
    shell cat /tmp/coloutPipe | colout "^Line ([0-9]+) of \"(.*/)?(?:$|(.+?)(?:(\.[^.]*)|))\"" yellow,none,white,white bold | colout "(0x\S+) <(\S+)\+([0-9]+)>" blue,green,blue normal &
    logging_on
end
define info hookpost-line
    logging_off
end


# Don't forget to clean the adhoc pipe.
define hook-quit
    shell rm -f /tmp/coloutPipe
end

